von neumann programming liberated style algebra functional programs growing conventional languages programming inherent enormous stronger defects basic level word fat style weak time primitive inherited ancestor programming common coupling von computer close neumann state transitions programming division semantics expressions world statements powerful effectively inability building forms combining programs existing lack mathematical properties reasoning programs founded alternative functional programming style forms combining creating programs functional programs structured data deal nonrepetitive nonrecursive hierarchically arguments require constructed machinery complex declarations procedure forms combining applicable generally programs higher high level build style conventional languages style functional programming variables range algebra programs forms operations combining programs algebra transform programs equations unknowns solve programs equations transforms high transformations school algebra carried algebraic laws language written combining programs forms power programming chosen algebraic power give laws algebra theorems general detailed termination conditions behavior large systems class programs computing classes style functional programming state transition language programming systems von rules unlike neumann languages states loosely semantics coupled state computation occurs transition major programming functional programs algebra combining forms languages functional programming von models computers neumann languages applicative computing systems state applicative systems transformation transition program termination program correctness metacomposition 