neumann von liberated programming algebra style functional programs programming languages growing conventional inherent enormous stronger basic level defects primitive word fat time style weak common inherited ancestor programming neumann von computer close coupling semantics transitions state programming division expressions world powerful statements effectively inability forms combining programs building mathematical lack existing properties programs reasoning founded style alternative programming functional forms combining programs creating data functional structured programs deal hierarchically nonrecursive nonrepetitive require arguments constructed complex machinery procedure declarations forms combining generally applicable level high higher build programs style languages conventional style functional programming algebra range programs variables forms combining programs operations algebra programs transform programs equations solve unknowns equations high transforms algebra school transformations algebraic language carried laws written combining programs forms chosen programming power algebraic power algebra general give laws detailed theorems behavior termination conditions large computing systems programs class classes programming style functional programming state language transition languages systems neumann von unlike rules semantics loosely states coupled transition computation state major occurs algebra combining programs programming functional forms programming languages functional languages models neumann von computers applicative computing systems transformation transition systems program state applicative correctness program termination metacomposition 