programming von neumann liberated style functional algebra programs growing languages conventional programming inherent enormous stronger level defects basic weak time style word primitive fat programming ancestor inherited common neumann von close coupling computer state semantics division transitions programming world expressions statements inability powerful effectively building forms combining programs existing mathematical lack reasoning properties programs style founded functional programming alternative creating forms combining programs data deal programs functional structured nonrecursive nonrepetitive hierarchically require constructed arguments complex procedure declarations machinery applicable forms combining generally higher build high programs level conventional languages style style programming functional variables programs range algebra forms combining programs operations transform programs algebra solve equations unknowns programs transforms equations high school transformations algebra laws algebraic carried language written combining programs programming power forms chosen power algebraic laws theorems detailed algebra give general behavior conditions large termination programs classes class computing systems style programming functional transition programming state language rules languages neumann von unlike systems semantics loosely coupled states transition state major occurs computation combining programs functional algebra programming languages programming forms functional languages neumann von computers models systems applicative computing transition state applicative transformation program systems correctness program termination metacomposition 