implementation multiple stack environments model structures environment access control procedure require activation storage nested times exist control procedure straightforward activated allocation linked implement dynamic storage expensive blocks activation implementation space paper time presents technique stack hold single procedure storage activation retention necessarily tied durations storage technique property control flow identically simple case runs allocation usual deallocation stack automatic procedure multitasking technique applications valued label variables coroutines backtracking arguments initial discussed functional single implementation model processor real assumed multiple assumes processes coordinate passing explicitly control multiprocessor implementation requires technique basic allocation stack environments control structures dendrarchy allocation retention dynamic storage funarg access environments multitasking problem valued label variables coroutines backtracking systems control structures arguments extensible functional multiprocessor 